### chapter1.3

在实现当前章节的例子和习题时发现，编写链表确实很容易出现Bug，因为随时需要你就去维护好节点的next指针或者prev指针（对于java使用者来说，是没有指针的，但这里用C/C++中的指针概念来说明问题是合适的），特别是需要注意边界情况，在对first节点和last节点进行节点的插入和删除时需要特别小心。这在一定程度上增加了实现者的心智负担。那么如何更快地编写不容易出错的链表代码呢？那我们就得思考如何简化问题——如何避免在编写链表时处理非常容易出错的边界节点。一个办法就是牺牲一点点的内存空间，为链表在首节点或者尾节点处增加 **哨兵节点**（如果你对哨兵节点的概念不熟悉，请使用你最喜爱的搜索引擎）。这样做的好处就是避免非常多的边界问题，代码逻辑更加简单清晰，不容易滋生Bug。当然啦，代价就是会牺牲一点点的内存空间，对于大多数需求场景来说，这不是问题。总之，很难找到完美的实现方法；怎么选择，取决于决策者面临的实际问题。